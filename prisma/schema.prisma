generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ItemType {
  TOOL
  CONSUMABLE
  MATERIAL
  WEAPON
  ARMOR
  MISC
}

enum ToolKind {
  NONE
  PICKAXE
  ROD
  WEAPON
  ARMOR
}

enum LocationKind {
  MINE
  FISHING
  DUNGEON
}

enum Rarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY
  MYTHIC
}

enum EffectType {
  HEAL
  ENERGY
  BUFF_ATTACK
  BUFF_DEFENSE
  BUFF_DROP_RATE
  BUFF_CRIT
  BUFF_LUCK
  BUFF_WORK_PAYOUT
  BUFF_RESOURCE_YIELD
  DAMAGE
  SHIELD
  CLEANSE
}

enum EffectTarget {
  SELF
  ENEMY
  WEAPON
  ARMOR
  TOOL
}

model User {
  id          String    @id @db.VarChar(32)
  createdAt   DateTime  @default(now())
  vcoins      Int       @default(100)
  xp          Int       @default(0)
  level       Int       @default(1)
  skillPoints Int       @default(0)
  lastDailyAt DateTime?

  healthMax  Int       @default(100)
  health     Int       @default(100)
  attack     Int       @default(5)
  defense    Int       @default(2)
  energy     Int       @default(100)
  lastHealAt DateTime?
  deaths     Int       @default(0)

  strength  Int @default(1)
  agility   Int @default(1)
  intellect Int @default(1)
  luck      Int @default(1)

  equippedPickaxeId Int?
  equippedRodId     Int?
  equippedWeaponId  Int?
  equippedArmorId   Int?

  metadata Json?

  items UserItem[]
  bossDamages BossDamage[]
  raidMembers RaidMember[]
}

model Item {
  id         Int      @id @default(autoincrement())
  key        String   @unique
  name       String
  type       ItemType
  rarity     Rarity   @default(COMMON)
  price      Int      @default(0)
  buyable    Boolean  @default(true)
  sellable   Boolean  @default(true)
  usable     Boolean  @default(false)
  toolKind   ToolKind @default(NONE)
  tier       Int?
  power      Int?
  durability Int?
  metadata   Json?

  users   UserItem[]
  effects ItemEffect[]

  // Upgrades (ya estaban bien con nombres)
  upgradesFrom ItemUpgrade[] @relation("UpgradesFrom")
  upgradesTo   ItemUpgrade[] @relation("UpgradesTo")

  //  Relaciones agregadas para evitar el error:
  // Costes de upgrade -> ItemUpgradeCost.item
  upgradeCostItems ItemUpgradeCost[] @relation("CostItem")

  // Ingredientes de crafteo -> CraftIngredient.item
  ingredientOf CraftIngredient[] @relation("IngredientItem")

  // Entradas de drop -> DropEntry.item
  dropEntries DropEntry[]  @relation("DropEntryItem")
  CraftRecipe CraftRecipe?
}

model ItemEffect {
  id          Int          @id @default(autoincrement())
  itemId      Int
  type        EffectType
  target      EffectTarget @default(SELF)
  magnitude   Float
  durationSec Int?
  chance      Float?
  stacks      Boolean?     @default(false)
  metadata    Json?

  item Item @relation(fields: [itemId], references: [id], onDelete: Cascade)
}

model ItemUpgrade {
  id           Int @id @default(autoincrement())
  baseItemId   Int
  resultItemId Int
  costVcoins   Int @default(0)

  baseItem   Item @relation("UpgradesFrom", fields: [baseItemId], references: [id], onDelete: Cascade)
  resultItem Item @relation("UpgradesTo", fields: [resultItemId], references: [id], onDelete: Cascade)

  materials ItemUpgradeCost[]

  @@unique([baseItemId, resultItemId])
}

model ItemUpgradeCost {
  id        Int @id @default(autoincrement())
  upgradeId Int
  itemId    Int
  quantity  Int

  upgrade ItemUpgrade @relation(fields: [upgradeId], references: [id], onDelete: Cascade)
  //  Nombra la relaci贸n y enlaza el lado opuesto en Item.upgradeCostItems
  item    Item        @relation("CostItem", fields: [itemId], references: [id], onDelete: Restrict)
}

model CraftRecipe {
  id           Int     @id @default(autoincrement())
  resultItemId Int
  station      String?
  metadata     Json?

  resultItem  Item              @relation(fields: [resultItemId], references: [id], onDelete: Cascade)
  ingredients CraftIngredient[]

  @@unique([resultItemId])
}

model CraftIngredient {
  id       Int @id @default(autoincrement())
  recipeId Int
  itemId   Int
  quantity Int

  recipe CraftRecipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  //  Nombra la relaci贸n y enlaza el lado opuesto en Item.ingredientOf
  item   Item        @relation("IngredientItem", fields: [itemId], references: [id], onDelete: Restrict)
}

model UserItem {
  id       Int    @id @default(autoincrement())
  userId   String
  itemId   Int
  quantity Int    @default(1)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  item Item @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([userId, itemId])
}

model Location {
  id           Int          @id @default(autoincrement())
  slug         String       @unique
  name         String
  kind         LocationKind
  requiredKind ToolKind
  requiredTier Int          @default(1)
  dangerLevel  Int          @default(0)
  metadata     Json?

  encounters LocationEncounter[]
}

model Monster {
  id         Int    @id @default(autoincrement())
  key        String @unique
  name       String
  level      Int    @default(1)
  hp         Int
  attack     Int
  defense    Int
  critChance Float  @default(0.05)
  xpReward   Int    @default(5)
  vcoinsMin  Int    @default(0)
  vcoinsMax  Int    @default(0)

  dropTableId Int?
  //  Nombra la relaci贸n y crea el opuesto en DropTable.monsters
  dropTable   DropTable? @relation("MonsterDropTable", fields: [dropTableId], references: [id], onDelete: SetNull)

  metadata   Json?
  encounters LocationEncounter[]
}

model DropTable {
  id      Int         @id @default(autoincrement())
  key     String      @unique
  name    String
  entries DropEntry[]

  //  lado opuesto para Monster.dropTable
  monsters Monster[] @relation("MonsterDropTable")
}

model DropEntry {
  id      Int @id @default(autoincrement())
  tableId Int
  itemId  Int
  weight  Int @default(1)
  minQty  Int @default(1)
  maxQty  Int @default(1)

  table DropTable @relation(fields: [tableId], references: [id], onDelete: Cascade)
  //  Nombra la relaci贸n y enlaza el lado opuesto en Item.dropEntries
  item  Item      @relation("DropEntryItem", fields: [itemId], references: [id], onDelete: Restrict)
}

model LocationEncounter {
  id         Int @id @default(autoincrement())
  locationId Int
  monsterId  Int
  weight     Int @default(1)

  location Location @relation(fields: [locationId], references: [id], onDelete: Cascade)
  monster  Monster  @relation(fields: [monsterId], references: [id], onDelete: Cascade)

  @@unique([locationId, monsterId])
}

model Boss {
  id            Int      @id @default(autoincrement())
  name          String
  rotationWeek  Int      @unique
  hp            Int
  maxHp         Int
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  metadata      Json?

  damages BossDamage[]
}

model BossDamage {
  id           Int      @id @default(autoincrement())
  bossId       Int
  userId       String
  damage       Int      @default(0)
  lastAttackAt DateTime @default(now())

  boss Boss @relation(fields: [bossId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([bossId, userId])
}

model Raid {
  id        Int      @id @default(autoincrement())
  threadId  String   @unique
  state     String   @default("FORMING")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  metadata  Json?

  members RaidMember[]
}

model RaidMember {
  id          Int      @id @default(autoincrement())
  raidId      Int
  userId      String
  role        String
  joinedAt    DateTime @default(now())
  contribution Int     @default(0)
  metadata    Json?

  raid Raid @relation(fields: [raidId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([raidId, userId])
}
