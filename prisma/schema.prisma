generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ItemType {
  TOOL
  CONSUMABLE
  MATERIAL
  WEAPON
  ARMOR
  MISC
}

enum ToolKind {
  NONE
  PICKAXE
  ROD
  WEAPON
  ARMOR
}

enum LocationKind {
  MINE
  FISHING
  DUNGEON
}

enum Rarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY
  MYTHIC
}

enum EffectType {
  HEAL
  ENERGY
  BUFF_ATTACK
  BUFF_DEFENSE
  BUFF_DROP_RATE
  BUFF_CRIT
  BUFF_LUCK
  BUFF_WORK_PAYOUT
  BUFF_RESOURCE_YIELD
  DAMAGE
  SHIELD
  CLEANSE
}

enum EffectTarget {
  SELF
  ENEMY
  WEAPON
  ARMOR
  TOOL
}

enum GuildRole {
  LEADER
  OFFICER
  MEMBER
}

enum GuildMemberStatus {
  PENDING
  ACTIVE
}

enum GuildUpgradeType {
  DROP_RATE
  INVENTORY_CAPACITY
}

enum GuildBankTxType {
  COINS
  ITEM
}

enum MarketListingStatus {
  ACTIVE
  COMPLETED
  CANCELLED
}

model User {
  id          String    @id @db.VarChar(32)
  createdAt   DateTime  @default(now())
  vcoins      Int       @default(100)
  xp          Int       @default(0)
  level       Int       @default(1)
  skillPoints Int       @default(0)
  lastDailyAt DateTime?

  healthMax  Int       @default(100)
  health     Int       @default(100)
  attack     Int       @default(5)
  defense    Int       @default(2)
  energy     Int       @default(100)
  lastHealAt DateTime?
  deaths     Int       @default(0)

  strength  Int @default(1)
  agility   Int @default(1)
  intellect Int @default(1)
  luck      Int @default(1)

  equippedPickaxeId Int?
  equippedRodId     Int?
  equippedWeaponId  Int?
  equippedArmorId   Int?

  metadata Json?

  items UserItem[]
  bossDamages BossDamage[]
  raidMembers RaidMember[]
  guildMembership GuildMember?
  guildsLed       Guild[]       @relation("GuildLeader")
  marketListings  MarketListing[] @relation("MarketSeller")
  marketPurchases MarketTx[]      @relation("MarketBuyer")
  guildBankTxs    GuildBankTx[]
}

model Item {
  id         Int      @id @default(autoincrement())
  key        String   @unique
  name       String
  type       ItemType
  rarity     Rarity   @default(COMMON)
  price      Int      @default(0)
  buyable    Boolean  @default(true)
  sellable   Boolean  @default(true)
  usable     Boolean  @default(false)
  toolKind   ToolKind @default(NONE)
  tier       Int?
  power      Int?
  durability Int?
  metadata   Json?

  users   UserItem[]
  effects ItemEffect[]

  // Upgrades (ya estaban bien con nombres)
  upgradesFrom ItemUpgrade[] @relation("UpgradesFrom")
  upgradesTo   ItemUpgrade[] @relation("UpgradesTo")

  //  Relaciones agregadas para evitar el error:
  // Costes de upgrade -> ItemUpgradeCost.item
  guildBankItems GuildBankItem[] @relation("GuildBankItemItem")
  guildBankTxs   GuildBankTx[]   @relation("GuildBankTxItem")
  marketListings MarketListing[] @relation("MarketListingItem")
  upgradeCostItems ItemUpgradeCost[] @relation("CostItem")

  // Ingredientes de crafteo -> CraftIngredient.item
  ingredientOf CraftIngredient[] @relation("IngredientItem")

  // Entradas de drop -> DropEntry.item
  dropEntries DropEntry[]  @relation("DropEntryItem")
  CraftRecipe CraftRecipe?
}

model ItemEffect {
  id          Int          @id @default(autoincrement())
  itemId      Int
  type        EffectType
  target      EffectTarget @default(SELF)
  magnitude   Float
  durationSec Int?
  chance      Float?
  stacks      Boolean?     @default(false)
  metadata    Json?

  item Item @relation(fields: [itemId], references: [id], onDelete: Cascade)
}

model ItemUpgrade {
  id           Int @id @default(autoincrement())
  baseItemId   Int
  resultItemId Int
  costVcoins   Int @default(0)

  baseItem   Item @relation("UpgradesFrom", fields: [baseItemId], references: [id], onDelete: Cascade)
  resultItem Item @relation("UpgradesTo", fields: [resultItemId], references: [id], onDelete: Cascade)

  materials ItemUpgradeCost[]

  @@unique([baseItemId, resultItemId])
}

model ItemUpgradeCost {
  id        Int @id @default(autoincrement())
  upgradeId Int
  itemId    Int
  quantity  Int

  upgrade ItemUpgrade @relation(fields: [upgradeId], references: [id], onDelete: Cascade)
  //  Nombra la relaci贸n y enlaza el lado opuesto en Item.upgradeCostItems
  item    Item        @relation("CostItem", fields: [itemId], references: [id], onDelete: Restrict)
}

model CraftRecipe {
  id           Int     @id @default(autoincrement())
  resultItemId Int
  station      String?
  metadata     Json?

  resultItem  Item              @relation(fields: [resultItemId], references: [id], onDelete: Cascade)
  ingredients CraftIngredient[]

  @@unique([resultItemId])
}

model CraftIngredient {
  id       Int @id @default(autoincrement())
  recipeId Int
  itemId   Int
  quantity Int

  recipe CraftRecipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  //  Nombra la relaci贸n y enlaza el lado opuesto en Item.ingredientOf
  item   Item        @relation("IngredientItem", fields: [itemId], references: [id], onDelete: Restrict)
}

model UserItem {
  id       Int    @id @default(autoincrement())
  userId   String
  itemId   Int
  quantity Int    @default(1)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  item Item @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([userId, itemId])
}

model Location {
  id           Int          @id @default(autoincrement())
  slug         String       @unique
  name         String
  kind         LocationKind
  requiredKind ToolKind
  requiredTier Int          @default(1)
  dangerLevel  Int          @default(0)
  metadata     Json?

  encounters LocationEncounter[]
}

model Monster {
  id         Int    @id @default(autoincrement())
  key        String @unique
  name       String
  level      Int    @default(1)
  hp         Int
  attack     Int
  defense    Int
  critChance Float  @default(0.05)
  xpReward   Int    @default(5)
  vcoinsMin  Int    @default(0)
  vcoinsMax  Int    @default(0)

  dropTableId Int?
  //  Nombra la relaci贸n y crea el opuesto en DropTable.monsters
  dropTable   DropTable? @relation("MonsterDropTable", fields: [dropTableId], references: [id], onDelete: SetNull)

  metadata   Json?
  encounters LocationEncounter[]
}

model DropTable {
  id      Int         @id @default(autoincrement())
  key     String      @unique
  name    String
  entries DropEntry[]

  //  lado opuesto para Monster.dropTable
  monsters Monster[] @relation("MonsterDropTable")
}

model DropEntry {
  id      Int @id @default(autoincrement())
  tableId Int
  itemId  Int
  weight  Int @default(1)
  minQty  Int @default(1)
  maxQty  Int @default(1)

  table DropTable @relation(fields: [tableId], references: [id], onDelete: Cascade)
  //  Nombra la relaci贸n y enlaza el lado opuesto en Item.dropEntries
  item  Item      @relation("DropEntryItem", fields: [itemId], references: [id], onDelete: Restrict)
}

model LocationEncounter {
  id         Int @id @default(autoincrement())
  locationId Int
  monsterId  Int
  weight     Int @default(1)

  location Location @relation(fields: [locationId], references: [id], onDelete: Cascade)
  monster  Monster  @relation(fields: [monsterId], references: [id], onDelete: Cascade)

  @@unique([locationId, monsterId])
}

model Boss {
  id            Int      @id @default(autoincrement())
  name          String
  rotationWeek  Int      @unique
  hp            Int
  maxHp         Int
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  metadata      Json?

  damages BossDamage[]
}

model BossDamage {
  id           Int      @id @default(autoincrement())
  bossId       Int
  userId       String
  damage       Int      @default(0)
  lastAttackAt DateTime @default(now())

  boss Boss @relation(fields: [bossId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([bossId, userId])
}

model Raid {
  id        Int      @id @default(autoincrement())
  threadId  String   @unique
  state     String   @default("FORMING")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  metadata  Json?

  members RaidMember[]
}

model RaidMember {
  id          Int      @id @default(autoincrement())
  raidId      Int
  userId      String
  role        String
  joinedAt    DateTime @default(now())
  contribution Int     @default(0)
  metadata    Json?

  raid Raid @relation(fields: [raidId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([raidId, userId])
}

model Guild {
  id          Int       @id @default(autoincrement())
  name        String    @unique
  description String?
  leaderId    String
  capacity    Int       @default(20)
  bankCoins   Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  metadata    Json?

  leader   User          @relation("GuildLeader", fields: [leaderId], references: [id], onDelete: Cascade)
  members  GuildMember[]
  upgrades GuildUpgrade[]
  bankItems GuildBankItem[]
  bankTransactions GuildBankTx[]
}

model GuildMember {
  id        Int                @id @default(autoincrement())
  guildId   Int
  userId    String
  role      GuildRole          @default(MEMBER)
  status    GuildMemberStatus  @default(PENDING)
  joinedAt  DateTime?
  createdAt DateTime           @default(now())

  guild Guild @relation(fields: [guildId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([guildId, userId])
  @@unique([userId])
}

model GuildUpgrade {
  id        Int              @id @default(autoincrement())
  guildId   Int
  type      GuildUpgradeType
  level     Int              @default(1)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  guild Guild @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@unique([guildId, type])
}

model GuildBankItem {
  id        Int      @id @default(autoincrement())
  guildId   Int
  itemId    Int
  quantity  Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  guild Guild @relation(fields: [guildId], references: [id], onDelete: Cascade)
  item  Item  @relation("GuildBankItemItem", fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([guildId, itemId])
}

model GuildBankTx {
  id        Int            @id @default(autoincrement())
  guildId   Int
  userId    String
  type      GuildBankTxType
  amount    Int?
  itemId    Int?
  quantity  Int?
  createdAt DateTime        @default(now())

  guild Guild @relation(fields: [guildId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  item  Item? @relation("GuildBankTxItem", fields: [itemId], references: [id], onDelete: SetNull)
}

model MarketListing {
  id           Int                 @id @default(autoincrement())
  sellerId     String
  itemId       Int
  qty          Int
  remainingQty Int
  price        Int
  status       MarketListingStatus @default(ACTIVE)
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt

  seller User  @relation("MarketSeller", fields: [sellerId], references: [id], onDelete: Cascade)
  item   Item  @relation("MarketListingItem", fields: [itemId], references: [id], onDelete: Cascade)
  sales  MarketTx[]
}

model MarketTx {
  id        Int      @id @default(autoincrement())
  listingId Int
  buyerId   String
  qty       Int
  price     Int
  createdAt DateTime @default(now())

  listing MarketListing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  buyer   User          @relation("MarketBuyer", fields: [buyerId], references: [id], onDelete: Cascade)
}
